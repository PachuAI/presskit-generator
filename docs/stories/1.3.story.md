# Story 1.3: Base de Datos y Modelos de Usuario

## Status
DONE

## Story
**Como** desarrollador del proyecto ÍTERA PressKit Generator,
**Quiero** diseñar e implementar un esquema de base de datos completo optimizado para artistas musicales con perfiles enriquecidos, Row Level Security, y triggers automáticos,
**Para que** tenga una fundación de datos sólida que soporte todas las funcionalidades del sistema con seguridad, performance y escalabilidad apropiadas

## Acceptance Criteria
1. El esquema de base de datos debe estar completamente implementado en Supabase con todas las tablas necesarias
2. Todas las tablas deben tener Row Level Security (RLS) habilitado con políticas apropiadas
3. Los triggers automáticos deben estar configurados para updated_at y creación de perfiles
4. Los índices de performance deben estar implementados para queries optimizadas
5. Las funciones de base de datos deben estar creadas para lógica de negocio crítica
6. Los tipos TypeScript deben estar generados automáticamente desde el esquema
7. Los servicios de datos deben estar implementados con validación completa usando Zod
8. Las migraciones de base de datos deben estar documentadas y versionadas

## Tasks / Subtasks

- [ ] Implementar esquema completo de base de datos (AC: 1)
  - [ ] Ejecutar script SQL para crear todas las tablas del esquema
  - [ ] Verificar tabla user_profiles con campos completos para artistas
  - [ ] Crear tabla presskits con content_data JSONB flexible
  - [ ] Crear tabla templates con configuración completa
  - [ ] Crear tablas de analytics_events y export_history
  - [ ] Verificar constraints y validaciones en todas las tablas

- [ ] Configurar Row Level Security completo (AC: 2)
  - [ ] Habilitar RLS en todas las tablas sensibles
  - [ ] Crear políticas de SELECT para acceso de usuarios
  - [ ] Crear políticas de INSERT/UPDATE/DELETE para modificaciones
  - [ ] Implementar política de límites de presskits por suscripción
  - [ ] Configurar políticas para presskits públicos vs privados
  - [ ] Verificar seguridad entre usuarios y aislamiento de datos

- [ ] Implementar triggers y funciones automáticas (AC: 3, 5)
  - [ ] Crear función update_updated_at_column() para timestamps
  - [ ] Aplicar triggers de updated_at en todas las tablas relevantes
  - [ ] Crear función generate_unique_slug() para URLs públicas
  - [ ] Implementar función update_subscription_features() automática
  - [ ] Crear trigger para auto-creación de perfil post-registro
  - [ ] Verificar funcionamiento de todos los triggers

- [ ] Optimizar performance con índices estratégicos (AC: 4)
  - [ ] Crear índices en user_profiles para auth_user_id, email
  - [ ] Crear índices en presskits para user_id, status, public_slug
  - [ ] Crear índices en analytics_events para queries temporales
  - [ ] Crear índices compuestos para queries complejas
  - [ ] Verificar performance de queries principales
  - [ ] Documentar strategy de indexing para mantenimiento

- [ ] Generar y configurar tipos TypeScript (AC: 6)
  - [ ] Configurar script para generar tipos desde Supabase
  - [ ] Crear types/database.ts con tipos completos y actualizados
  - [ ] Configurar regeneración automática en CI/CD
  - [ ] Verificar type safety en toda la aplicación
  - [ ] Documentar proceso de actualización de tipos
  - [ ] Integrar tipos con servicios existentes

- [ ] Implementar servicios de datos con validación (AC: 7)
  - [ ] Extender UserService con operaciones completas de perfil
  - [ ] Crear PressskitService con CRUD y validación Zod
  - [ ] Crear TemplateService para gestión de templates
  - [ ] Implementar schemas Zod para validación de todos los modelos
  - [ ] Configurar sanitización DOMPurify en todos los inputs
  - [ ] Implementar error handling robusto en servicios

- [ ] Crear sistema de migraciones y versionado (AC: 8)
  - [ ] Crear scripts/migration-helper.ts para gestión de migraciones
  - [ ] Documentar migración inicial en docs/database-setup.md
  - [ ] Crear script de seed para datos iniciales (templates básicos)
  - [ ] Configurar backup y restore procedures
  - [ ] Documentar rollback procedures para cambios críticos
  - [ ] Verificar integridad de datos post-migración

- [ ] Implementar validación de datos integral (AC: 1, 7)
  - [ ] Crear validation/schemas.ts con todos los Zod schemas
  - [ ] Implementar validación a nivel de API para todos los endpoints
  - [ ] Configurar validación de límites de archivo y contenido
  - [ ] Implementar sanitización de contenido JSONB
  - [ ] Verificar validación de social media URLs y emails
  - [ ] Testear todos los edge cases de validación

## Dev Notes

### Esquema Completo de Base de Datos
[Source: docs/architecture/9-database-schema.md, docs/architecture/4-data-models.md]

**Tablas principales a implementar:**

1. **user_profiles** - Perfiles completos de artistas:
```sql
CREATE TABLE user_profiles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    auth_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT NOT NULL UNIQUE,
    artist_name TEXT NOT NULL,
    full_name TEXT,
    avatar_url TEXT,
    bio TEXT,
    subscription_status TEXT NOT NULL DEFAULT 'free' 
        CHECK (subscription_status IN ('free', 'pro', 'enterprise')),
    presskit_limit INTEGER NOT NULL DEFAULT 3,
    social_media JSONB DEFAULT '{}',
    contact_email TEXT,
    phone TEXT,
    location TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

2. **presskits** - Almacén de presskits con content_data flexible:
```sql
CREATE TABLE presskits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    artist_name TEXT NOT NULL,
    template_type TEXT NOT NULL DEFAULT 'basic',
    status TEXT NOT NULL DEFAULT 'draft',
    is_public BOOLEAN NOT NULL DEFAULT FALSE,
    public_slug TEXT UNIQUE,
    content_data JSONB NOT NULL DEFAULT '{}',
    view_count INTEGER NOT NULL DEFAULT 0,
    download_count INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    published_at TIMESTAMPTZ
);
```

### Row Level Security Policies
[Source: docs/architecture/9-database-schema.md]

**Políticas críticas a implementar:**

```sql
-- Users only see their own data
CREATE POLICY "Users can view their own profile" ON user_profiles 
FOR SELECT USING (auth.uid() = auth_user_id);

-- Enforce presskit limits by subscription
CREATE POLICY "Enforce presskit limits" ON presskits FOR INSERT
WITH CHECK (
    (SELECT COUNT(*) FROM presskits WHERE user_id = NEW.user_id) < 
    (SELECT presskit_limit FROM user_profiles WHERE id = NEW.user_id)
);

-- Public presskits viewable by anyone
CREATE POLICY "Anyone can view public presskits" ON presskits 
FOR SELECT USING (is_public = TRUE AND status = 'published');
```

### Triggers y Funciones Automáticas
[Source: docs/architecture/9-database-schema.md]

**Funciones obligatorias:**

1. **update_updated_at_column()** - Timestamps automáticos:
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';
```

2. **generate_unique_slug()** - URLs únicas:
```sql
CREATE OR REPLACE FUNCTION generate_unique_slug(base_title TEXT)
RETURNS TEXT AS $$
-- Implementación completa de slug único con contador
```

3. **update_subscription_features()** - Límites por suscripción:
```sql
CREATE OR REPLACE FUNCTION update_subscription_features()
RETURNS TRIGGER AS $$
-- Auto-update user limits based on subscription changes
```

### Modelos de Datos TypeScript
[Source: docs/architecture/4-data-models.md]

**Interfaces principales a generar:**

```typescript
interface UserProfile {
  id: string;
  email: string;
  artist_name: string;
  full_name?: string;
  avatar_url?: string;
  bio?: string;
  subscription_status: 'free' | 'pro' | 'enterprise';
  presskit_limit: number;
  social_media?: {
    instagram?: string;
    twitter?: string;
    tiktok?: string;
    soundcloud?: string;
    spotify?: string;
    youtube?: string;
  };
  contact_email?: string;
  phone?: string;
  location?: string;
  created_at: string;
  updated_at: string;
}

interface PressKit {
  id: string;
  user_id: string;
  title: string;
  artist_name: string;
  template_type: 'basic' | 'electronic' | 'band' | 'solo';
  status: 'draft' | 'published' | 'archived';
  is_public: boolean;
  public_slug?: string;
  content_data: {
    biography: string;
    genre: string[];
    profile_photo?: string;
    press_photos: string[];
    social_media: Record<string, string>;
    contact_info: {
      booking_email: string;
      press_email?: string;
    };
    // ... más campos específicos del contenido
  };
  view_count: number;
  download_count: number;
  created_at: string;
  updated_at: string;
  published_at?: string;
}
```

### Servicios de Datos Requeridos
[Source: docs/architecture/source-tree-structure.md]

**Ubicaciones de servicios:**

```
src/lib/services/
├── user-service.ts           # CRUD completo de perfiles
├── presskit-service.ts       # Gestión de presskits
├── template-service.ts       # Templates y configuración
└── analytics-service.ts      # Events y tracking
```

**Ejemplo UserService extendido:**
```typescript
export class UserService {
  static async updateProfile(userId: string, data: UpdateProfileData) {
    // Validar con Zod schema
    const validated = UpdateProfileSchema.parse(data);
    
    // Sanitizar contenido
    const sanitized = {
      ...validated,
      bio: validated.bio ? DOMPurify.sanitize(validated.bio) : null
    };
    
    // Update en Supabase con RLS automático
    const { data: profile, error } = await supabase
      .from('user_profiles')
      .update(sanitized)
      .eq('id', userId)
      .select()
      .single();
      
    if (error) throw new DatabaseError('Profile update failed', error);
    return profile;
  }
}
```

### Schemas Zod para Validación
[Source: docs/architecture/coding-standards.md]

**Schemas obligatorios en validation/schemas.ts:**

```typescript
import { z } from 'zod';
import DOMPurify from 'isomorphic-dompurify';

export const UserProfileSchema = z.object({
  artist_name: z.string()
    .min(2, 'Nombre muy corto')
    .max(100, 'Nombre muy largo')
    .transform(input => DOMPurify.sanitize(input, { ALLOWED_TAGS: [] })),
  
  bio: z.string()
    .max(2000, 'Biografía muy larga')
    .optional()
    .transform(input => input ? DOMPurify.sanitize(input, { ALLOWED_TAGS: ['b', 'i', 'br'] }) : undefined),
    
  social_media: z.object({
    instagram: z.string().url('URL de Instagram inválida').optional(),
    spotify: z.string().url('URL de Spotify inválida').optional(),
    // ... más redes sociales
  }).optional()
});

export const PressskitContentSchema = z.object({
  biography: z.string().min(10, 'Biografía muy corta').max(5000, 'Biografía muy larga'),
  genre: z.array(z.string()).min(1, 'Debe especificar al menos un género'),
  contact_info: z.object({
    booking_email: z.string().email('Email de booking inválido')
  })
});
```

### Índices de Performance
[Source: docs/architecture/9-database-schema.md]

**Índices críticos para performance:**

```sql
-- User profiles
CREATE INDEX idx_user_profiles_auth_user_id ON user_profiles(auth_user_id);
CREATE INDEX idx_user_profiles_subscription_status ON user_profiles(subscription_status);

-- Presskits
CREATE INDEX idx_presskits_user_id ON presskits(user_id);
CREATE INDEX idx_presskits_status ON presskits(status);
CREATE INDEX idx_presskits_public_slug ON presskits(public_slug) WHERE public_slug IS NOT NULL;
CREATE INDEX idx_presskits_is_public ON presskits(is_public) WHERE is_public = TRUE;

-- Analytics
CREATE INDEX idx_analytics_events_type_created ON analytics_events(event_type, created_at);
```

### Testing

#### Estrategia de Testing
[Source: docs/architecture/14-test-strategy.md]

**Tests de base de datos obligatorios:**

- **Unit tests:** Servicios de datos (UserService, PressskitService)
- **Integration tests:** RLS policies y triggers
- **Schema tests:** Validación de constraints y tipos
- **Performance tests:** Queries con grandes datasets

**Ubicación de tests:**
```
tests/
├── unit/services/
│   ├── user-service.test.ts
│   └── presskit-service.test.ts
├── integration/database/
│   ├── rls-policies.test.ts
│   └── triggers.test.ts
└── schema/
    └── validation.test.ts
```

**Ejemplo test RLS:**
```typescript
describe('RLS Policies', () => {
  it('should prevent users from accessing other user profiles', async () => {
    // Test isolation between users
    const result = await supabase
      .from('user_profiles')
      .select()
      .eq('id', otherUserId);
      
    expect(result.data).toHaveLength(0); // Should not see other user's data
  });
});
```

### Datos de Seed Iniciales
**Templates básicos a crear:**
- Template "Básico" - Layout simple para principiantes
- Template "Electrónico" - Optimizado para DJs
- Template "Banda" - Para grupos musicales
- Template "Solista" - Para artistas individuales

### Backup y Recovery
- Backup automático diario via Supabase
- Scripts de restore para desarrollo local
- Documentación de recovery procedures
- Monitoreo de integridad referencial

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Historia inicial de base de datos y modelos | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be completed by dev agent*

### Debug Log References
*To be completed by dev agent*

### Completion Notes List
*To be completed by dev agent*

### File List
*To be completed by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation*